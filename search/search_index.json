{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"mcpgateway-client","text":"<p>A lightweight SnapEnv McpGateway client for SnapEnv McpGateway server, enabling AI Agents access to MCP server's running on local computer.</p>"},{"location":"modules/cli/","title":"cli","text":""},{"location":"modules/cli/#mcpgateway_client.cli.foo","title":"<code>foo(param1=typer.Argument(..., help='Primeiro par\u00e2metro do comando FOO.'), param2=typer.Argument(..., help='Segundo par\u00e2metro do comando FOO.'))</code>","text":"<p>Executes the FOO command with two required parameters.</p> <p>Parameters:</p> Name Type Description Default <code>param1</code> <code>str</code> <p>First parameter for the FOO command.</p> <code>Argument(..., help='Primeiro par\u00e2metro do comando FOO.')</code> <code>param2</code> <code>str</code> <p>Second parameter for the FOO command.</p> <code>Argument(..., help='Segundo par\u00e2metro do comando FOO.')</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This function does not return any value.</p> Source code in <code>src/mcpgateway_client/cli.py</code> <pre><code>@app.command(help=\"Executa o comando FOO com dois par\u00e2metros obrigat\u00f3rios.\")\ndef foo(\n    param1: str = typer.Argument(..., help=\"Primeiro par\u00e2metro do comando FOO.\"),\n    param2: str = typer.Argument(..., help=\"Segundo par\u00e2metro do comando FOO.\"),\n) -&gt; None:\n    \"\"\"\n    Executes the FOO command with two required parameters.\n\n    Args:\n        param1 (str): First parameter for the FOO command.\n        param2 (str): Second parameter for the FOO command.\n\n    Returns:\n        None: This function does not return any value.\n    \"\"\"\n    typer.echo(f\"Executando FOO com param1={param1} e param2={param2}\")\n</code></pre>"},{"location":"modules/cli/#mcpgateway_client.cli.main_callback","title":"<code>main_callback(ctx, version=typer.Option(None, '--version', help='Exibe a vers\u00e3o do pacote e sai.', is_eager=True, callback=lambda value: show_version_and_exit() if value else None))</code>","text":"<p>Main callback for the CLI application. Displays the main panel if no subcommand is invoked.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The Typer context object for the CLI invocation.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This function does not return any value.</p> Source code in <code>src/mcpgateway_client/cli.py</code> <pre><code>@app.callback(invoke_without_command=True)\ndef main_callback(\n    ctx: typer.Context,\n    version: bool = typer.Option(\n        None,\n        \"--version\",\n        help=\"Exibe a vers\u00e3o do pacote e sai.\",\n        is_eager=True,\n        callback=lambda value: show_version_and_exit() if value else None,\n    ),\n) -&gt; None:\n    \"\"\"\n    Main callback for the CLI application. Displays the main panel if no subcommand is invoked.\n\n    Args:\n        ctx (typer.Context): The Typer context object for the CLI invocation.\n\n    Returns:\n        None: This function does not return any value.\n    \"\"\"\n    if ctx.invoked_subcommand is None and not version:\n        console.print(\n            Panel.fit(\n                \"[bold cyan]mcpgateway-client CLI[/bold cyan]\\n\\n\"\n                \"[white]Use um dos comandos abaixo:[/white]\\n\"\n                \"[green]- foo[/green]: executa a\u00e7\u00e3o foo com dois argumentos obrigat\u00f3rios\\n\"\n                \"[green]- bar[/green]: executa a\u00e7\u00e3o bar com dois argumentos obrigat\u00f3rios\\n\\n\"\n                \"[yellow]Dica:[/yellow] use '--help' ap\u00f3s qualquer comando para mais detalhes.\",\n                title=\"[bold blue]SnapEnv CLI[/bold blue]\",\n                border_style=\"bright_blue\",\n            )\n        )\n</code></pre>"},{"location":"modules/cli/#mcpgateway_client.cli.register","title":"<code>register(gateway_url=typer.Option(..., '--gateway-url', '-g', help='Gateway URL to connect to. Ex: ws://localhost:8765/mcp/register'), gateway_auth_token=typer.Option(None, '--auth-token', '-a', help='Set the auth token for the gateway. Ex: Bearer abcdef123456'), stdio=typer.Option(..., '--stdio', '-i', help='Subprocess command to start. Ex: npx -y @modelcontextprotocol/server-filesystem ./'), server_name=typer.Option(..., '--server-name', '-n', help='Server name for registration. Ex: local-mcpserver-001'), header=HEADER_OPTION, log_level=LOG_LEVEL, dry_run=DRY_RUN)</code>","text":"<p>Executes the REGISTER command with required and optional parameters.</p> <p>Parameters:</p> Name Type Description Default <code>gateway_url</code> <code>str</code> <p>URL do gateway para conex\u00e3o.</p> <code>Option(..., '--gateway-url', '-g', help='Gateway URL to connect to. Ex: ws://localhost:8765/mcp/register')</code> <code>gateway_auth_token</code> <code>str</code> <p>Token de autentica\u00e7\u00e3o.</p> <code>Option(None, '--auth-token', '-a', help='Set the auth token for the gateway. Ex: Bearer abcdef123456')</code> <code>stdio</code> <code>str</code> <p>Comando subprocesso.</p> <code>Option(..., '--stdio', '-i', help='Subprocess command to start. Ex: npx -y @modelcontextprotocol/server-filesystem ./')</code> <code>server_name</code> <code>str</code> <p>Nome do servidor.</p> <code>Option(..., '--server-name', '-n', help='Server name for registration. Ex: local-mcpserver-001')</code> <code>header</code> <code>str</code> <p>Headers HTTP.</p> <code>HEADER_OPTION</code> Usage Examples <p>cli register \\     --gateway-url https://gateway.snapby.com \\     --auth-token \"Bearer abcdef123456\" \\     --stdio \"/usr/local/bin/mcpserve\" \\     --server-name \"snapby-server-001\"</p> <p>cli register -g https://localhost:8080 -i ./run.sh -n dev-env \\     -h \"Authorization: Bearer devtoken\" -h \"X-Custom-Header: test\"</p> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Esta fun\u00e7\u00e3o n\u00e3o retorna valor.</p> Source code in <code>src/mcpgateway_client/cli.py</code> <pre><code>@app.command(help=\"Register your MCP Server to the Gateway.\")\ndef register(\n    gateway_url: str = typer.Option(\n        ...,\n        \"--gateway-url\",\n        \"-g\",\n        help=\"Gateway URL to connect to. Ex: ws://localhost:8765/mcp/register\",\n    ),\n    gateway_auth_token: str = typer.Option(\n        None,\n        \"--auth-token\",\n        \"-a\",\n        help=\"Set the auth token for the gateway. Ex: Bearer abcdef123456\",\n    ),\n    stdio: str = typer.Option(\n        ...,\n        \"--stdio\",\n        \"-i\",\n        help=\"Subprocess command to start. Ex: npx -y @modelcontextprotocol/server-filesystem ./\",\n    ),\n    server_name: str = typer.Option(\n        ...,\n        \"--server-name\",\n        \"-n\",\n        help=\"Server name for registration. Ex: local-mcpserver-001\",\n    ),\n    header: list[str] = HEADER_OPTION,\n    log_level: str = LOG_LEVEL,\n    dry_run: bool = DRY_RUN,\n) -&gt; None:\n    \"\"\"\n    Executes the REGISTER command with required and optional parameters.\n\n    Args:\n        gateway_url (str): URL do gateway para conex\u00e3o.\n        gateway_auth_token (str, optional): Token de autentica\u00e7\u00e3o.\n        stdio (str): Comando subprocesso.\n        server_name (str): Nome do servidor.\n        header (str, optional): Headers HTTP.\n\n    Usage Examples:\n        &gt; cli register \\\\\n            --gateway-url https://gateway.snapby.com \\\\\n            --auth-token \"Bearer abcdef123456\" \\\\\n            --stdio \"/usr/local/bin/mcpserve\" \\\\\n            --server-name \"snapby-server-001\"\n\n        &gt; cli register -g https://localhost:8080 -i ./run.sh -n dev-env \\\\\n            -h \"Authorization: Bearer devtoken\" -h \"X-Custom-Header: test\"\n\n    Returns:\n        None: Esta fun\u00e7\u00e3o n\u00e3o retorna valor.\n    \"\"\"\n    setup_logger(level=log_level)\n    headers = {}\n    if header:\n        for item in header:\n            if \":\" not in item:\n                msg = f\"Invalid header: '{item}'.\"\n                raise ValueError(msg)\n            key, value = item.split(\":\", 1)\n            headers[key.strip()] = value.strip()\n\n    ws_args = StdioToWsArgs(\n        gateway_url=gateway_url,\n        gateway_auth_token=gateway_auth_token,\n        # port=args.port,\n        # enable_cors=args.enable_cors,\n        # health_endpoints=args.health_endpoint,\n        server_name=server_name,\n        # server_id=args.server_id,\n        # require_gateway=args.require_gateway,\n        headers=headers,\n        stdio_cmd=stdio,\n        # ssl_verify=args.ssl_verify,\n        # ssl_ca_cert=args.ssl_ca_cert,\n        log_level=log_level,\n    )\n\n    # config_panel = Panel(\n    #     Pretty(ws_args.__dict__, expand_all=True),\n    #     title=\"\ud83d\udce6 Client Register Settings\",\n    #     # subtitle=\"Objeto Python formatado\",\n    #     border_style=\"cyan\",\n    #     expand=True,\n    # )\n    # console.print(config_panel)\n\n    tree = Tree(\"\ud83d\udce6 [bold cyan]Settings[/]\")\n\n    for key, value in ws_args.__dict__.items():\n        if isinstance(value, dict):\n            branch = tree.add(f\"[bold yellow]{key}[/]:\")\n            for sub_key, sub_value in value.items():\n                branch.add(f\"[green]{sub_key}[/]: {sub_value}\")\n        else:\n            tree.add(f\"[bold yellow]{key}[/]: {value}\")\n\n    console.print(Panel(tree, title=\"Client Register\", border_style=\"magenta\", expand=True))\n\n    if not dry_run:\n        client_main(ws_args)\n</code></pre>"},{"location":"modules/cli/#mcpgateway_client.cli.show_version_and_exit","title":"<code>show_version_and_exit()</code>","text":"<p>Exibe vers\u00e3o usando Rich e sai.</p> Source code in <code>src/mcpgateway_client/cli.py</code> <pre><code>def show_version_and_exit() -&gt; None:\n    \"\"\"Exibe vers\u00e3o usando Rich e sai.\"\"\"\n    console.print(\n        Panel.fit(\n            f\"[bold green]SnapBy MCP Gateway:[/bold green] [cyan]CLIENT v{VERSION}[/cyan]\\n\\n\"\n            f\"[bold red]https://snapby.com[/bold red]\",\n            title=\"[bold blue]Version[/bold blue]\",\n            border_style=\"green\",\n        )\n    )\n    raise typer.Exit()\n</code></pre>"},{"location":"modules/client_websocket/","title":"client_websocket","text":"<p>MCP (Model Context Protocol) stdio-to-ws Gateway - Modified Version</p>"},{"location":"modules/client_websocket/#mcpgateway_client.client_websocket.GatewayClient","title":"<code>GatewayClient</code>","text":"<p>Gateway client that handles communication with the upstream gateway</p> Source code in <code>src/mcpgateway_client/client_websocket.py</code> <pre><code>class GatewayClient:\n    \"\"\"Gateway client that handles communication with the upstream gateway\"\"\"\n\n    def __init__(\n        self,\n        gateway_url: str,\n        server_name: str,\n        server_id: Optional[str] = None,\n        headers: Optional[dict[str, str]] = None,\n        ssl_context: Optional[ssl.SSLContext] = None,\n    ):\n        self.gateway_url = gateway_url\n        self.server_name = server_name\n        self.server_id = server_id or str(uuid.uuid4())\n        # self.websocket: Optional[ClientConnection] = None\n        self.websocket: Optional[websockets.ClientConnection] = None\n        self.message_handlers: dict[str, Callable[[Any, Optional[str]], Awaitable[None]]] = {}\n        self.is_connected = False\n        self.headers = headers or {}\n        self.ssl_context = ssl_context\n        self._listen_task: Optional[asyncio.Task] = None\n\n    def add_message_handler(self, name: str, handler: Callable[[Any, Optional[str]], Awaitable[None]]) -&gt; None:\n        self.message_handlers[name] = handler\n\n    async def send(self, message: Any) -&gt; None:\n        if not self.websocket or not self.is_connected:\n            logger.debug(\"Gateway not connected, unable to send message.\")\n            return\n\n        message_str = json.dumps(message)\n        try:\n            await self.websocket.send(message_str)\n            logger.debug(f\"Message sent to gateway: {message_str[:100]}...\")\n        except websockets.exceptions.ConnectionClosed:\n            logger.warning(\"Failed to send message: Gateway connection closed.\")\n            self.is_connected = False\n        except Exception:  # pylint: disable=broad-except\n            logger.exception(\"Failed to send message to gateway\")\n            # self.is_connected = False # Potentially, but ConnectionClosed is more specific\n\n    # Dentro da classe GatewayClient\n    async def _request_stdio_subprocess(  # noqa: C901\n        self,\n        method_name: str,\n        params: dict,\n        proc_stdin: Optional[asyncio.StreamWriter],\n        pending_stdio_requests: dict[Any, asyncio.Future],\n        loop: asyncio.AbstractEventLoop,\n        timeout_sec: float = 15.0,\n    ) -&gt; Any:\n        if not proc_stdin or proc_stdin.is_closing():\n            logger.error(f\"Subprocess stdin not available for sending request '{method_name}'.\")\n            raise OSError(f\"Subprocess stdin not available for '{method_name}'.\")  # noqa: TRY003\n\n        stdio_req_id = str(uuid.uuid4())\n        future = loop.create_future()\n        pending_stdio_requests[stdio_req_id] = future\n\n        request_to_stdio_payload = {\n            \"jsonrpc\": \"2.0\",\n            \"id\": stdio_req_id,\n            \"method\": method_name,\n            \"params\": params,\n        }\n        request_str = json.dumps(request_to_stdio_payload) + \"\\n\"\n        logger.debug(f\"Client (proxy) -&gt; STDIO (Req ID: {stdio_req_id}, Method: {method_name}): {request_str[:200]}...\")\n\n        try:\n            proc_stdin.write(request_str.encode(\"utf-8\"))\n            await proc_stdin.drain()\n        except (ConnectionResetError, BrokenPipeError) as e:\n            logger.error(f\"Pipe error writing to subprocess stdin for {stdio_req_id} ('{method_name}'): {e}\")  # noqa: TRY400\n            if stdio_req_id in pending_stdio_requests:  # Garante que s\u00f3 remove se existir\n                pending_stdio_requests.pop(stdio_req_id)\n            if not future.done():\n                future.set_exception(e)\n            raise\n        except Exception as e_write:\n            logger.exception(f\"Unexpected error writing to subprocess stdin for {stdio_req_id} ('{method_name}')\")\n            if stdio_req_id in pending_stdio_requests:\n                pending_stdio_requests.pop(stdio_req_id)\n            if not future.done():\n                future.set_exception(e_write)\n            raise\n\n        try:\n            logger.debug(\n                f\"Waiting for STDIO response for internal req ID {stdio_req_id} ('{method_name}', Timeout: {timeout_sec}s)\"\n            )\n            return await asyncio.wait_for(future, timeout=timeout_sec)\n        except asyncio.TimeoutError:\n            logger.error(  # noqa: TRY400\n                f\"Timeout waiting for STDIO response for method '{method_name}', internal req ID '{stdio_req_id}'.\"\n            )\n            if stdio_req_id in pending_stdio_requests:  # Limpa se timeout\n                pending_stdio_requests.pop(stdio_req_id)\n            raise\n        except Exception as e_await:\n            logger.debug(\n                f\"Error from future for STDIO method '{method_name}', internal req ID '{stdio_req_id}': {e_await}\"\n            )\n            # pending_stdio_requests deve ter sido removido se set_exception foi chamado em read_stdout\n            raise\n\n    async def _internal_listen_loop(self) -&gt; None:  # noqa: C901\n        \"\"\"Internal loop to continuously listen for messages.\"\"\"\n        try:\n            if not self.websocket:  # Should not happen if called correctly\n                logger.error(\"WebSocket not available for listening.\")\n                return\n\n            logger.debug(\"Starting internal listen loop for gateway messages.\")\n            async for message_raw in self.websocket:\n                message_str = str(message_raw)[:200]  # Limit log size\n                logger.info(f\"Received gateway message: {message_str}...\")\n\n                try:\n                    msg_data = json.loads(message_raw)\n                    msg_id = msg_data.get(\"id\") if isinstance(msg_data, dict) else None\n                    for handler_name, handler_func in self.message_handlers.items():\n                        # Schedule handler execution to not block the listen loop\n                        asyncio.create_task(  # noqa: RUF006\n                            handler_func(msg_data, msg_id),  # type: ignore[arg-type]\n                            name=f\"gw_handler_{handler_name}_{msg_id or 'no_id'}\",\n                        )\n                except json.JSONDecodeError:\n                    logger.exception(f\"Received invalid JSON from gateway: {message_raw!r}\")\n                except Exception:  # pylint: disable=broad-except\n                    logger.exception(\"Error processing gateway message in handler\")\n        except websockets.exceptions.ConnectionClosedOK:\n            logger.info(\"Gateway connection closed normally (OK).\")\n        except websockets.exceptions.ConnectionClosedError as e:\n            logger.warning(f\"Gateway connection closed with error: {e.code} {e.reason}\")\n        except websockets.exceptions.ConnectionClosed as e:  # Catch-all\n            logger.warning(f\"Gateway connection closed unexpectedly: {e!r}\")\n        except asyncio.CancelledError:\n            logger.info(\"Gateway listening loop was cancelled.\")\n        except Exception:  # pylint: disable=broad-except\n            logger.exception(\"Unhandled exception in gateway listening loop.\")\n        finally:\n            self.is_connected = False\n            logger.debug(\"Gateway internal listen loop finished.\")\n\n    # Dentro da classe GatewayClient\n    async def _handle_server_request_during_handshake(\n        self,\n        request_data: dict,\n        proc_stdin: Optional[asyncio.StreamWriter],\n        pending_stdio_requests: dict[Any, asyncio.Future],\n        loop: asyncio.AbstractEventLoop,\n    ) -&gt; None:\n        method = request_data.get(\"method\")\n        remote_gateway_req_id = request_data.get(\"id\")\n        response_payload = None\n        # ... (defini\u00e7\u00f5es de client_name, client_version)\n        client_name = \"mcpgateway-client-stdio\"\n        client_version = \"0.1.0\"\n\n        if method == \"initialize\":\n            # ... (como antes, usando \"2024-11-05\" para protocolVersion) ...\n            logger.info(f\"Responding to 'initialize' request (ID: {remote_gateway_req_id}) from gateway.\")\n            client_announced_protocol_version = \"2024-11-05\"\n            response_payload = {\n                \"jsonrpc\": \"2.0\",\n                \"id\": remote_gateway_req_id,\n                \"result\": {\n                    \"protocolVersion\": client_announced_protocol_version,\n                    \"serverInfo\": {\"name\": client_name, \"version\": client_version},\n                    \"capabilities\": {},\n                },\n            }\n        elif method == \"tools/list\":\n            logger.info(\n                f\"Received 'tools/list' (ID: {remote_gateway_req_id}) from remote gateway. Querying stdio subprocess.\"\n            )\n            if not proc_stdin:\n                logger.error(\"Cannot query stdio for tools/list: proc_stdin is None.\")\n                response_payload = {\n                    \"jsonrpc\": \"2.0\",\n                    \"id\": remote_gateway_req_id,\n                    \"error\": {\"code\": -32000, \"message\": \"Internal error: stdio not available\"},\n                }\n            else:\n                try:\n                    stdio_result_content = await self._request_stdio_subprocess(\n                        \"tools/list\", {}, proc_stdin, pending_stdio_requests, loop, timeout_sec=20.0\n                    )\n                    if isinstance(stdio_result_content, dict) and \"tools\" in stdio_result_content:\n                        response_payload = {\n                            \"jsonrpc\": \"2.0\",\n                            \"id\": remote_gateway_req_id,\n                            \"result\": stdio_result_content,\n                        }\n                        logger.info(\n                            f\"Responding to remote gateway's 'tools/list' (ID: {remote_gateway_req_id}) with {len(stdio_result_content['tools'])} tools from stdio.\"\n                        )\n                    else:\n                        logger.error(\n                            f\"STDIO server provided invalid or unexpected result for tools/list: {stdio_result_content}\"\n                        )\n                        response_payload = {\n                            \"jsonrpc\": \"2.0\",\n                            \"id\": remote_gateway_req_id,\n                            \"error\": {\"code\": -32002, \"message\": \"Invalid response from stdio server for tools/list\"},\n                        }\n                except asyncio.TimeoutError:\n                    logger.error(  # noqa: TRY400\n                        f\"Timeout querying stdio subprocess for 'tools/list' (for remote gateway request ID {remote_gateway_req_id}).\"\n                    )\n                    response_payload = {\n                        \"jsonrpc\": \"2.0\",\n                        \"id\": remote_gateway_req_id,\n                        \"error\": {\"code\": -32000, \"message\": \"Timeout obtaining tools from stdio server\"},\n                    }\n                except Exception as e:\n                    logger.exception(\n                        f\"Error querying stdio subprocess for 'tools/list' (for remote gateway request ID {remote_gateway_req_id}): {e}\"  # noqa: TRY401\n                    )\n                    response_payload = {\n                        \"jsonrpc\": \"2.0\",\n                        \"id\": remote_gateway_req_id,\n                        \"error\": {\"code\": -32000, \"message\": f\"Internal error obtaining tools: {e!s}\"},\n                    }\n        else:\n            logger.warning(\n                f\"Received unhandled request method '{method}' (ID: {remote_gateway_req_id}) from gateway during handshake.\"\n            )\n            response_payload = {\n                \"jsonrpc\": \"2.0\",\n                \"id\": remote_gateway_req_id,\n                \"error\": {\"code\": -32601, \"message\": \"Method not found\"},\n            }\n\n        if response_payload and self.websocket and self.is_connected:\n            logger.debug(\n                f\"Sending response for gateway request '{method}' (ID: {remote_gateway_req_id}): {str(response_payload)[:200]}...\"\n            )\n            await self.send(response_payload)\n        elif not self.websocket or not self.is_connected:\n            logger.warning(f\"Cannot send response for '{method}', websocket not available or not connected.\")\n\n    async def connect_and_run_listen_loop(  # noqa: C901\n        self,\n        proc_stdin: Optional[asyncio.StreamWriter],\n        pending_stdio_requests: dict[Any, asyncio.Future],\n        loop: asyncio.AbstractEventLoop,\n    ) -&gt; bool:\n        \"\"\"Connects, performs handshake, and runs the listening loop.\"\"\"\n        if self._listen_task and not self._listen_task.done():\n            logger.warning(\"connect_and_run_listen_loop called while a listen task is already active.\")\n            return self.is_connected\n\n        # server_id para nosso pedido de registro\n        # Se self.server_id n\u00e3o foi passado, GatewayClient gera um uuid4.\n        # \u00c9 crucial usar ESTE ID para rastrear a resposta do NOSSO 'register'.\n        client_registration_id = self.server_id\n\n        try:\n            logger.info(f\"Attempting to connect to gateway: {self.gateway_url}\")\n            async with websockets.connect(\n                self.gateway_url,\n                ping_interval=20,\n                ping_timeout=20,\n                close_timeout=10,\n                additional_headers=self.headers,\n                ssl=self.ssl_context,\n            ) as ws_connection:\n                self.websocket = ws_connection  # Atribui aqui\n                self.is_connected = True\n                logger.info(\"Successfully connected to gateway.\")\n\n                registration_params = {\"name\": self.server_name, \"version\": \"1.0.0\", \"capabilities\": {}}\n                registration_req = {\n                    \"jsonrpc\": \"2.0\",\n                    \"id\": client_registration_id,\n                    \"method\": \"register\",\n                    \"params\": registration_params,\n                }\n                logger.info(f\"Sending client registration request (ID: {client_registration_id}): {registration_req}\")\n                await self.send(registration_req)  # Usa self.send que usa self.websocket\n\n                # Handshake Loop: Espera por v\u00e1rias mensagens, incluindo respostas e pedidos do servidor\n                # O servidor mcpport.gateway envia:\n                # 1. Ack: {\"status\": \"received\", \"id\": client_registration_id, ...}\n                # 2. Pedido: {\"method\": \"initialize\", \"id\": SERVER_INIT_ID, ...}\n                # (Cliente responde ao initialize)\n                # 3. Notifica\u00e7\u00e3o: {\"method\": \"notifications/initialized\", ...}\n                # (Servidor pode dormir 5s aqui)\n                # 4. Pedido: {\"method\": \"tools/list\", \"id\": SERVER_TOOLS_ID, ...}\n                # (Cliente responde ao tools/list)\n                # 5. Confirma\u00e7\u00e3o final: {\"status\": \"registered\", \"id\": client_registration_id, ...}\n\n                fully_registered_with_gateway = False\n                # Timeout total para o handshake, e.g. 60 segundos\n                handshake_timeout = 60.0\n                loop_start_time = asyncio.get_running_loop().time()\n\n                while not fully_registered_with_gateway:\n                    remaining_time = handshake_timeout - (asyncio.get_running_loop().time() - loop_start_time)\n                    if remaining_time &lt;= 0:\n                        logger.error(\"Handshake timed out waiting for 'status: registered' from gateway.\")\n                        return False\n\n                    try:\n                        if self.websocket is None:  # Checagem para mypy\n                            logger.error(\"Websocket is None, cannot recv. Breaking handshake.\")\n                            return False  # Ou levante uma exce\u00e7\u00e3o\n                        else:\n                            # Usa um timeout menor para cada recv para permitir a verifica\u00e7\u00e3o do timeout geral\n                            response_raw = await asyncio.wait_for(\n                                self.websocket.recv(), timeout=min(15.0, remaining_time)\n                            )\n                    except asyncio.TimeoutError:\n                        # Isso significa que o recv individual deu timeout, n\u00e3o necessariamente o handshake todo.\n                        # O loop externo verificar\u00e1 o timeout total do handshake.\n                        logger.debug(\"Individual recv timed out, continuing handshake loop.\")\n                        continue\n                    except websockets.exceptions.ConnectionClosed:\n                        logger.warning(\"Websocket connection closed during handshake.\")\n                        return False\n\n                    logger.debug(f\"Handshake recv: {str(response_raw)[:300]}...\")\n                    try:\n                        msg_data = json.loads(response_raw)\n                        msg_id = msg_data.get(\"id\")\n\n                        # Cen\u00e1rio 1: Resposta ao nosso pedido de registro\n                        if msg_id == client_registration_id:\n                            if msg_data.get(\"status\") == \"received\":\n                                logger.info(\n                                    f\"Gateway ACKed our registration (ID: {client_registration_id}). Continuing handshake.\"\n                                )\n                            elif msg_data.get(\"status\") == \"registered\":\n                                logger.info(\n                                    f\"Gateway confirmed full registration (ID: {client_registration_id}). Handshake successful.\"\n                                )\n                                fully_registered_with_gateway = True\n                                # N\u00e3o saia do loop ainda, pode haver mais mensagens antes do listen_loop\n                            elif \"result\" in msg_data:  # Caso o servidor envie um JSON-RPC result para o register\n                                logger.info(\n                                    f\"Gateway responded with 'result' for our registration (ID: {client_registration_id}). Assuming ACK.\"\n                                )\n                            elif \"error\" in msg_data:\n                                logger.error(\n                                    f\"Gateway rejected our registration (ID: {client_registration_id}). Error: {msg_data['error']}\"\n                                )\n                                return False\n                            else:\n                                logger.warning(\n                                    f\"Received unknown status/response for our registration ID {client_registration_id}: {msg_data}\"\n                                )\n\n                        # Cen\u00e1rio 2: Um pedido do servidor para n\u00f3s\n                        elif \"method\" in msg_data and msg_id is not None:  # msg_id N\u00c3O \u00e9 client_registration_id\n                            logger.info(f\"Received request from gateway: method '{msg_data['method']}', ID '{msg_id}'.\")\n                            await self._handle_server_request_during_handshake(\n                                msg_data,\n                                proc_stdin,  # Passado aqui\n                                pending_stdio_requests,  # Passado aqui\n                                loop,  # Passado aqui\n                            )\n\n                        # Cen\u00e1rio 3: Uma notifica\u00e7\u00e3o do servidor\n                        elif \"method\" in msg_data and msg_id is None:\n                            if msg_data[\"method\"] == \"notifications/initialized\":\n                                logger.info(\"Received 'notifications/initialized' from gateway.\")\n                            else:\n                                logger.info(f\"Received notification from gateway: {msg_data['method']}\")\n\n                        # Cen\u00e1rio 4: Um erro geral do servidor (n\u00e3o ligado a um ID nosso)\n                        elif msg_data.get(\"status\") == \"error\":\n                            logger.error(\n                                f\"Handshake: Received general error from gateway: {msg_data.get('message', 'Unknown error')}\"\n                            )\n                            if \"Initialization failed\" in msg_data.get(\n                                \"message\", \"\"\n                            ) or \"Unsupported protocol version\" in msg_data.get(\"message\", \"\"):\n                                logger.error(\"Server-side initialization or protocol handshake failed. Aborting.\")\n                                return False\n                            # Adicione um caso para fechar se o erro for especificamente do nosso registro\n                            if msg_data.get(\"message\", \"\").startswith(\n                                f\"Registration processing error for ID {client_registration_id}\"\n                            ):\n                                logger.error(\n                                    f\"Gateway reported error processing our registration {client_registration_id}. Aborting.\"\n                                )\n                                return False\n                        else:\n                            logger.debug(f\"Received other message during handshake: {str(msg_data)[:100]}...\")\n\n                    except json.JSONDecodeError:\n                        logger.error(f\"Handshake: Invalid JSON received: {response_raw!r}\")  # noqa: TRY400\n                    except Exception as e:\n                        logger.exception(f\"Error processing message during handshake: {e}\")  # noqa: TRY401\n                        return False  # Erro inesperado no processamento\n\n                if not fully_registered_with_gateway:  # Saiu do loop por timeout\n                    logger.error(f\"Handshake: Invalid JSON received: {response_raw!r}\")\n                    return False\n\n                logger.info(\n                    \"Handshake sequence complete. Starting main message listening loop (_internal_listen_loop).\"\n                )\n                await self._internal_listen_loop()  # Onde o cliente escuta por chamadas de ferramentas etc.\n                return True  # Indica que o handshake e o in\u00edcio do listen loop foram OK\n\n        except websockets.exceptions.InvalidStatus as e:\n            logger.error(f\"Gateway connection failed: HTTP {e.response.status_code}. Headers: {e.response.headers}\")  # noqa: TRY400\n        except ConnectionRefusedError:\n            logger.error(f\"Connection refused by gateway at {self.gateway_url}\")  # noqa: TRY400\n        except asyncio.TimeoutError:  # Timeout do websockets.connect ou do handshake_timeout geral\n            logger.error(f\"Timeout during connection or overall handshake with {self.gateway_url}\")  # noqa: TRY400\n        except asyncio.CancelledError:\n            logger.info(\"Gateway connection and listen task was cancelled.\")\n        except Exception:\n            logger.exception(\"Unhandled error during gateway connection or listening\")\n        finally:\n            self.is_connected = False\n            self.websocket = None  # &lt;&lt;&lt; Garante que est\u00e1 None ao sair\n            logger.debug(\"connect_and_run_listen_loop method finished.\")\n        return False\n\n    async def close(self) -&gt; None:\n        logger.info(\"Closing GatewayClient...\")\n        self.is_connected = False\n\n        # The _internal_listen_loop runs within connect_and_run_listen_loop's context.\n        # If connect_and_run_listen_loop is a task, cancelling that task will\n        # cause the 'async with websockets.connect(...)' to exit, closing the websocket.\n        # Direct cancellation of _listen_task is not needed if it's not directly managed.\n        # However, if connect_and_run_listen_loop is itself a task, that's what needs cancelling.\n\n        # if self.websocket and not self.websocket.closed:\n        if self.websocket:\n            logger.debug(\"Explicitly closing websocket in GatewayClient.close().\")\n            try:\n                await self.websocket.close(code=1000, reason=\"Client shutdown initiated\")\n            except Exception:  # pylint: disable=broad-except\n                logger.exception(\"Exception during websocket close in GatewayClient.close\")\n\n        self.websocket = None\n        self.message_handlers.clear()\n        logger.info(\"GatewayClient resources released.\")\n</code></pre>"},{"location":"modules/client_websocket/#mcpgateway_client.client_websocket.GatewayClient.connect_and_run_listen_loop","title":"<code>connect_and_run_listen_loop(proc_stdin, pending_stdio_requests, loop)</code>  <code>async</code>","text":"<p>Connects, performs handshake, and runs the listening loop.</p> Source code in <code>src/mcpgateway_client/client_websocket.py</code> <pre><code>async def connect_and_run_listen_loop(  # noqa: C901\n    self,\n    proc_stdin: Optional[asyncio.StreamWriter],\n    pending_stdio_requests: dict[Any, asyncio.Future],\n    loop: asyncio.AbstractEventLoop,\n) -&gt; bool:\n    \"\"\"Connects, performs handshake, and runs the listening loop.\"\"\"\n    if self._listen_task and not self._listen_task.done():\n        logger.warning(\"connect_and_run_listen_loop called while a listen task is already active.\")\n        return self.is_connected\n\n    # server_id para nosso pedido de registro\n    # Se self.server_id n\u00e3o foi passado, GatewayClient gera um uuid4.\n    # \u00c9 crucial usar ESTE ID para rastrear a resposta do NOSSO 'register'.\n    client_registration_id = self.server_id\n\n    try:\n        logger.info(f\"Attempting to connect to gateway: {self.gateway_url}\")\n        async with websockets.connect(\n            self.gateway_url,\n            ping_interval=20,\n            ping_timeout=20,\n            close_timeout=10,\n            additional_headers=self.headers,\n            ssl=self.ssl_context,\n        ) as ws_connection:\n            self.websocket = ws_connection  # Atribui aqui\n            self.is_connected = True\n            logger.info(\"Successfully connected to gateway.\")\n\n            registration_params = {\"name\": self.server_name, \"version\": \"1.0.0\", \"capabilities\": {}}\n            registration_req = {\n                \"jsonrpc\": \"2.0\",\n                \"id\": client_registration_id,\n                \"method\": \"register\",\n                \"params\": registration_params,\n            }\n            logger.info(f\"Sending client registration request (ID: {client_registration_id}): {registration_req}\")\n            await self.send(registration_req)  # Usa self.send que usa self.websocket\n\n            # Handshake Loop: Espera por v\u00e1rias mensagens, incluindo respostas e pedidos do servidor\n            # O servidor mcpport.gateway envia:\n            # 1. Ack: {\"status\": \"received\", \"id\": client_registration_id, ...}\n            # 2. Pedido: {\"method\": \"initialize\", \"id\": SERVER_INIT_ID, ...}\n            # (Cliente responde ao initialize)\n            # 3. Notifica\u00e7\u00e3o: {\"method\": \"notifications/initialized\", ...}\n            # (Servidor pode dormir 5s aqui)\n            # 4. Pedido: {\"method\": \"tools/list\", \"id\": SERVER_TOOLS_ID, ...}\n            # (Cliente responde ao tools/list)\n            # 5. Confirma\u00e7\u00e3o final: {\"status\": \"registered\", \"id\": client_registration_id, ...}\n\n            fully_registered_with_gateway = False\n            # Timeout total para o handshake, e.g. 60 segundos\n            handshake_timeout = 60.0\n            loop_start_time = asyncio.get_running_loop().time()\n\n            while not fully_registered_with_gateway:\n                remaining_time = handshake_timeout - (asyncio.get_running_loop().time() - loop_start_time)\n                if remaining_time &lt;= 0:\n                    logger.error(\"Handshake timed out waiting for 'status: registered' from gateway.\")\n                    return False\n\n                try:\n                    if self.websocket is None:  # Checagem para mypy\n                        logger.error(\"Websocket is None, cannot recv. Breaking handshake.\")\n                        return False  # Ou levante uma exce\u00e7\u00e3o\n                    else:\n                        # Usa um timeout menor para cada recv para permitir a verifica\u00e7\u00e3o do timeout geral\n                        response_raw = await asyncio.wait_for(\n                            self.websocket.recv(), timeout=min(15.0, remaining_time)\n                        )\n                except asyncio.TimeoutError:\n                    # Isso significa que o recv individual deu timeout, n\u00e3o necessariamente o handshake todo.\n                    # O loop externo verificar\u00e1 o timeout total do handshake.\n                    logger.debug(\"Individual recv timed out, continuing handshake loop.\")\n                    continue\n                except websockets.exceptions.ConnectionClosed:\n                    logger.warning(\"Websocket connection closed during handshake.\")\n                    return False\n\n                logger.debug(f\"Handshake recv: {str(response_raw)[:300]}...\")\n                try:\n                    msg_data = json.loads(response_raw)\n                    msg_id = msg_data.get(\"id\")\n\n                    # Cen\u00e1rio 1: Resposta ao nosso pedido de registro\n                    if msg_id == client_registration_id:\n                        if msg_data.get(\"status\") == \"received\":\n                            logger.info(\n                                f\"Gateway ACKed our registration (ID: {client_registration_id}). Continuing handshake.\"\n                            )\n                        elif msg_data.get(\"status\") == \"registered\":\n                            logger.info(\n                                f\"Gateway confirmed full registration (ID: {client_registration_id}). Handshake successful.\"\n                            )\n                            fully_registered_with_gateway = True\n                            # N\u00e3o saia do loop ainda, pode haver mais mensagens antes do listen_loop\n                        elif \"result\" in msg_data:  # Caso o servidor envie um JSON-RPC result para o register\n                            logger.info(\n                                f\"Gateway responded with 'result' for our registration (ID: {client_registration_id}). Assuming ACK.\"\n                            )\n                        elif \"error\" in msg_data:\n                            logger.error(\n                                f\"Gateway rejected our registration (ID: {client_registration_id}). Error: {msg_data['error']}\"\n                            )\n                            return False\n                        else:\n                            logger.warning(\n                                f\"Received unknown status/response for our registration ID {client_registration_id}: {msg_data}\"\n                            )\n\n                    # Cen\u00e1rio 2: Um pedido do servidor para n\u00f3s\n                    elif \"method\" in msg_data and msg_id is not None:  # msg_id N\u00c3O \u00e9 client_registration_id\n                        logger.info(f\"Received request from gateway: method '{msg_data['method']}', ID '{msg_id}'.\")\n                        await self._handle_server_request_during_handshake(\n                            msg_data,\n                            proc_stdin,  # Passado aqui\n                            pending_stdio_requests,  # Passado aqui\n                            loop,  # Passado aqui\n                        )\n\n                    # Cen\u00e1rio 3: Uma notifica\u00e7\u00e3o do servidor\n                    elif \"method\" in msg_data and msg_id is None:\n                        if msg_data[\"method\"] == \"notifications/initialized\":\n                            logger.info(\"Received 'notifications/initialized' from gateway.\")\n                        else:\n                            logger.info(f\"Received notification from gateway: {msg_data['method']}\")\n\n                    # Cen\u00e1rio 4: Um erro geral do servidor (n\u00e3o ligado a um ID nosso)\n                    elif msg_data.get(\"status\") == \"error\":\n                        logger.error(\n                            f\"Handshake: Received general error from gateway: {msg_data.get('message', 'Unknown error')}\"\n                        )\n                        if \"Initialization failed\" in msg_data.get(\n                            \"message\", \"\"\n                        ) or \"Unsupported protocol version\" in msg_data.get(\"message\", \"\"):\n                            logger.error(\"Server-side initialization or protocol handshake failed. Aborting.\")\n                            return False\n                        # Adicione um caso para fechar se o erro for especificamente do nosso registro\n                        if msg_data.get(\"message\", \"\").startswith(\n                            f\"Registration processing error for ID {client_registration_id}\"\n                        ):\n                            logger.error(\n                                f\"Gateway reported error processing our registration {client_registration_id}. Aborting.\"\n                            )\n                            return False\n                    else:\n                        logger.debug(f\"Received other message during handshake: {str(msg_data)[:100]}...\")\n\n                except json.JSONDecodeError:\n                    logger.error(f\"Handshake: Invalid JSON received: {response_raw!r}\")  # noqa: TRY400\n                except Exception as e:\n                    logger.exception(f\"Error processing message during handshake: {e}\")  # noqa: TRY401\n                    return False  # Erro inesperado no processamento\n\n            if not fully_registered_with_gateway:  # Saiu do loop por timeout\n                logger.error(f\"Handshake: Invalid JSON received: {response_raw!r}\")\n                return False\n\n            logger.info(\n                \"Handshake sequence complete. Starting main message listening loop (_internal_listen_loop).\"\n            )\n            await self._internal_listen_loop()  # Onde o cliente escuta por chamadas de ferramentas etc.\n            return True  # Indica que o handshake e o in\u00edcio do listen loop foram OK\n\n    except websockets.exceptions.InvalidStatus as e:\n        logger.error(f\"Gateway connection failed: HTTP {e.response.status_code}. Headers: {e.response.headers}\")  # noqa: TRY400\n    except ConnectionRefusedError:\n        logger.error(f\"Connection refused by gateway at {self.gateway_url}\")  # noqa: TRY400\n    except asyncio.TimeoutError:  # Timeout do websockets.connect ou do handshake_timeout geral\n        logger.error(f\"Timeout during connection or overall handshake with {self.gateway_url}\")  # noqa: TRY400\n    except asyncio.CancelledError:\n        logger.info(\"Gateway connection and listen task was cancelled.\")\n    except Exception:\n        logger.exception(\"Unhandled error during gateway connection or listening\")\n    finally:\n        self.is_connected = False\n        self.websocket = None  # &lt;&lt;&lt; Garante que est\u00e1 None ao sair\n        logger.debug(\"connect_and_run_listen_loop method finished.\")\n    return False\n</code></pre>"}]}